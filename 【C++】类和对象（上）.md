@[TOC](文章目录)



----





# 1.面向过程和面向对象初步认识  





**C语言**是**面向过程的**，关注的是**过程**，分析出求解问题的步骤，通过函数调用**逐步解决问题**  





**C++**是基于**面向对象的**，关注的是**对象**，将一件事情拆分成不同的对象，靠对象之间的交互完
成。  



![image-20221003135010977](https://iubaopicbed.oss-cn-shenzhen.aliyuncs.com/img2/picbed202210031350295.png)



**面向过程思想**偏向于我们做一件事的流程，首先做什么，其次做什么，最后做什么。

举个例子：像我们平时洗衣服的时候，可能是这种情况：

把衣服脱下来——找一个盆——放点洗衣粉——加点水——浸泡10分钟——揉一揉——清洗第一遍——没洗干净再洗第二遍——拧干——晾起来

![image-20221003135921581](https://iubaopicbed.oss-cn-shenzhen.aliyuncs.com/img2/picbed202210031359736.png)



**面向对象思想**偏向于了解一个人，这个人的性格、特长是怎么样的，有没有遗传到什么能力，有没有家族病史。

举个例子：平时洗衣服的时候，也可能是这种情况：

把衣服脱下来——打开全自动洗衣机——扔衣服——按钮——晾起来



![image-20221003140531762](https://iubaopicbed.oss-cn-shenzhen.aliyuncs.com/img2/picbed202210031405909.png)





当然你也不要指望上述这点文字能一下子把面向对象认识得清清楚楚，还需要在后续的学习中慢慢体会它的博大精深，这也是为什么标题叫初步认识！！！





----





# 2.类的引入  



**C语言结构体中只能定义变量，在C++中，结构体内不仅可以定义变量，也可以定义函数。**

比如：之前在数据结构初阶中

[栈和队列实质性操作]: https://blog.csdn.net/dongming8886/article/details/124596112

用**C语言方式实现的栈，结构体中只能定义变量**；现在以**C++方式实现，
会发现struct中也可以定义函数  **



> 因为C++刚诞生之际，我们的祖师爷原本是想在C语言的基础上扩展，加入了类和对象,而C语言的结构体就很类似于现在的类，
>
> 于是在C++中就对struct进行了升级，使其成为了第一个版本的类，但后续就慢慢引入了新的关键词class（C++更喜欢用）
>
> 当然C++为了兼容C语言，struct也保留了C语言中的用法。



```c++
#include<iostream>
#include<stdlib.h>
using namespace std;

typedef int DataType;
struct Stack   //结构体定义类，在C++中更喜欢用class来代替。
{
   	DataType* _array;
	size_t _capacity;
	size_t _size;
    
//////////////////////////////////////////////////////////////
    //C++对struct进行升级，可以在里面定义函数
	void Init(size_t capacity)
	{
		_array = (DataType*)malloc(sizeof(DataType) * capacity);
		if (nullptr == _array)
		{
			perror("malloc申请空间失败");
			return;
		}
		_capacity = capacity;
		_size = 0;
	}
	void Push(const DataType& data)
	{
		// 扩容
		_array[_size] = data;
		++_size;
	}
	DataType Top()
	{
		return _array[_size - 1];
	}
	void Destroy()
	{
		if (_array)
		{
			free(_array);
			_array = nullptr;
			_capacity = 0;
			_size = 0;
		}
	}
};

int main()
{
	Stack s;
	s.Init(10);
	s.Push(1);
	cout << s.Top() << endl;
	s.Destroy();
	return 0;
}
```







# 3.类和对象



C++面向对象的三大特性为：==封装、继承、多态==



C++认为==万事万物都皆为对象==，对象上有其属性和行为



**例如：**

​	人可以作为对象，属性有姓名、年龄、身高、体重...，行为有走、跑、跳、吃饭、唱歌...

​	车也可以作为对象，属性有轮胎、方向盘、车灯...,行为有载人、放音乐、放空调...

​	具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类





# 4.类的定义  



## 4.1类的定义

其实**类的定义**跟C语言的结构体差不多，只不过在面向对象中C中的结构体只是定义了变量(对象)的声明（属性），没有定义函数（方法）

而类中，可以有**变量声明（属性），也可以有函数（方法）**



```c++
class className
{
	// 类体：由成员函数和成员变量组成
}; // 一定要注意后面的分号

//比如上面的栈
class stack
{
    
};
```



**class为定义类的关键字**，ClassName为类的名字，**{}中为类的主体**，注意类定义结束时后面**分
号不能省略**。
类体中内容称为**类的成员**：类中的**变量**称为类的**属性**或**成员变量**; 类中的**函数**称为类的**方法**或者
**成员函数**。  





类的两种定义方式：  



1. 声明和定义全部放在类体中，需注意：成员函数如果在类中定义，编译器可能会将其当成内
   联函数处理。  

![image-20221003143627062](https://iubaopicbed.oss-cn-shenzhen.aliyuncs.com/img2/picbed202210031436145.png)



2. 类声明放在.h文件中，成员函数定义放在.cpp文件中，注意：**成员函数名前需要加类名::  **(这个就涉及到类的作用域，下面有介绍)



![image-20221003143957975](https://iubaopicbed.oss-cn-shenzhen.aliyuncs.com/img2/picbed202210031439040.png)

==注意==：上面代码中的public和private，先不急着理解，下面有介绍。





一般情况下，更期望采用第二种方式。**注意：文章中只是为了方便演示使用方式一定义类，各位朋友后序工
作中尽量使用第二种。**  





## 4.2成员变量命名规则的建议



为什么有一些C++代码，喜欢在变量前或后面加“__”横杆呢？

我们来看下面代码

```c++
// 我们看看这个函数，是不是很僵硬？
class Date
{
public:
	void Init(int year)
	{
		// 这里的year到底是成员变量，还是函数形参？
		year = year;
	}
private:
	int year;
};
// 所以一般都建议这样
class Date
{
public:
	void Init(int year)
	{
		_year = year;
	}
private:
	int _year;
};
// 或者这样
class Date
{
public:
	void Init(int year)
	{
		mYear = year;
	}
private:
	int mYear;
};
// 其他方式也可以的，主要看公司要求。一般都是加个前缀或者后缀标识区分就行
```







# 5.类的访问限定符及封装  



## 5.1访问限定符  



C++实现封装的方式：**用类将对象的属性与方法结合在一块，让对象更加完善，通过访问权限选
择性的将其接口提供给外部的用户使用  **



![image-20221003144645974](https://iubaopicbed.oss-cn-shenzhen.aliyuncs.com/img2/picbed202210031446017.png)





【访问限定符说明】  



1. **public修饰的成员在类外可以直接被访问**

2. **protected和private修饰的成员在类外不能直接被访问(此处protected和private是类似的)**

3. **访问权限作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止**

4. **如果后面没有访问限定符，作用域就到 } 即类结束。**

5. **class的默认访问权限为private，struct为public(因为struct要兼容C)  **



注意：访问限定符只在编译时有用，当数据映射到内存后，没有任何访问限定符上的区别  



一些习惯用法：成员属性设置为私有

**优点1：**将所有成员属性设置为私有，可以自己控制读写权限

**优点2：**对于写权限，我们可以检测数据的有效性







## 5.2 封装  



前面介绍过面向对象的三大特性：**封装、继承、多态**。  

那什么是封装呢？  

封装：**将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来
和对象进行交互。  **

封装的意义：

* 将属性和行为作为一个整体，表现生活中的事物
* 将属性和行为加以权限控制



封装本质上是一种管理，让用户更方便使用类。比如：对于电脑这样一个复杂的设备，提供给用
户的就只有开关机键、通过键盘输入，显示器，USB插孔等，让用户和计算机进行交互，完成日
常事务。但实际上电脑真正工作的却是CPU、显卡、内存等一些硬件元件。  



![image-20221003145439316](https://iubaopicbed.oss-cn-shenzhen.aliyuncs.com/img2/picbed202210031454775.png)



>对于计算机使用者而言，不用关心内部核心部件，比如主板上线路是如何布局的，CPU内部是如
>何设计的等，用户只需要知道，怎么开机、怎么通过键盘和鼠标与计算机进行交互即可。因此**计
>算机厂商在出厂时，在外部套上壳子，将内部实现细节隐藏起来，仅仅对外提供开关机、鼠标以
>及键盘插孔等，让用户可以与计算机进行交互即可。**



**在C++语言中实现封装，可以通过类将数据以及操作数据的方法进行有机结合，通过访问权限来
隐藏对象内部实现细节，控制哪些方法可以在类外部直接被使用  **







# 6.类的作用域  



**类定义了一个新的作用域**，类的所有成员都在类的作用域中。在类体外定义成员时，**需要使用 ::
作用域操作符**指明成员属于哪个类域。  



```c++
class Person
{
public:
	void PrintPersonInfo();
private:
	char _name[20];
	char _gender[3];
	int _age;
};

// 这里需要指定PrintPersonInfo是属于Person这个类域
//我们可以想象一下，如果不加操作符::那么，它会怎么样？
void Person::PrintPersonInfo()
{
	cout << _name << " " << _gender << " " << _age << endl;
}
```



> 如果不加操作符，那么编译器是无法知道它是在哪个类的，那么这个函数，也无法编译通过，
>
> 用上述列子举例，不加Person::，而你的函数中，无缘无故出现了\_name，\_gender,\_age三个
>
> 未知变量，编译器会认为这是变量未定义。





# 7.类的实例化  



**用类类型创建对象的过程，称为类的实例化**



1. **类是对对象进行描述的**，是一个**模型**一样的东西，限定了类有哪些成员，定义出一个类并**没
   有分配实际的内存空间**来存储它；比如：入学时填写的学生信息表，表格就可以看成是一个
   类，来描述具体学生信息。

2. 一个类可以实例化出多个对象，**实例化出的对象 占用实际的物理空间，存储类成员变量**

做个比方。类实例化出对象就像现实中使用建筑设计图建造出房子，**类就像是设计图**，只设
计出需要什么东西，但是并没有实体的建筑存在，同样类也只是一个设计，实例化出的对象
才能实际存储数据，占用物理空间 ， **对象就像是建筑出来的房子**





![image-20221003151202852](https://iubaopicbed.oss-cn-shenzhen.aliyuncs.com/img2/picbed202210031512932.png)





在代码表示



![image-20221003151231475](https://iubaopicbed.oss-cn-shenzhen.aliyuncs.com/img2/picbed202210031512531.png)







# 8.类对象模型  



## 8.1 如何计算类对象的大小  





```c++
class A
{
public:
	void PrintA()
	{
		cout << _a << endl;
	}
private:
	char _a;
};
```



**问题：类中既可以有成员变量，又可以有成员函数，那么一个类的对象中包含了什么？如何计算
一个类的大小？** 

要计算类的大小，我们得知道它的存储方式，那它的存储方式究竟是怎么样的呢？



## 8.2 类对象的存储方式猜测  



我们的C++祖师爷的设计的时候，有过三种方案。



1. **对象中包含类的各个成员** 

![image-20221003200218481](https://iubaopicbed.oss-cn-shenzhen.aliyuncs.com/img2/picbed202210032002539.png)



缺陷：每个对象中成员变量是不同的，但是调用同一份函数，如果按照此种方式存储，当一
个类创建多个对象时，**每个对象中都会保存一份代码，相同代码保存多次，浪费空间。那么
如何解决呢？**  





这就产生了第二种方案

2. **代码只保存一份，在对象中保存存放代码的地址**  



![image-20221003200418906](https://iubaopicbed.oss-cn-shenzhen.aliyuncs.com/img2/picbed202210032004956.png)



方案二固然比方案一很大程度上节省了空间，但是每一个对象中都要存储一个地址，有没有更好的方案呢？



这时候显然又产生了第三种方案



3. **只保存成员变量，成员函数存放在公共的代码段**





![image-20221003201426399](https://iubaopicbed.oss-cn-shenzhen.aliyuncs.com/img2/picbed202210032014487.png)



不管从空间节省，还是代码的重复利用的角度来看，第三种方案都是最优的，C++也正是采用了这个方案



在C++中，类内的成员变量和成员函数分开存储

只有非静态成员变量才属于类的对象上

那么上面的问题就得以解决了



![image-20221003201732017](https://iubaopicbed.oss-cn-shenzhen.aliyuncs.com/img2/picbed202210032017092.png)



```C++
class B //那这个类的大小是多少呢？  
{
public:
	void PrintA()
	{
		cout << _a << endl;
	}
private:
	char _a;
	int _b;
};
```



上面B的大小的多少呢？ 是5吗？？？

我们来看看正确结果---》8

![image-20221003202000539](https://iubaopicbed.oss-cn-shenzhen.aliyuncs.com/img2/picbed202210032020574.png)





为什么是8个字节，而不是5字节呢？

可能C语言学的好的朋友就想到了**内存对齐**

是的没错，就是内存对齐，C++中类大小的计算跟C语言的结构体大小的计算是一模一样的

这里就不过多叙述了，照搬一些之前的一些内容，之前的文章有详细解释过

[结构体内存对齐]: https://blog.csdn.net/dongming8886/article/details/123953410









```C++
class C
{
public:
	void Print()
	{

	}
};

class D
{

};
```

上述两个类的大小又是多少呢？是0吗？



![image-20221003203330913](https://iubaopicbed.oss-cn-shenzhen.aliyuncs.com/img2/picbed202210032033959.png)



显然不是了，为什么是1而不是0呢？

首先，我们知道成员函数和成员变量是分开存储，所以它们两个本质上是一样大小的，类中都没有成员变量

按道理来说应该是0个字节呀？为什么是1呢，是因为编译器要区分它们的区别，用一个字节来占位。





**结论：一个类的大小，实际就是该类中”成员变量”之和，当然要注意内存对齐
注意空类的大小，空类比较特殊，编译器给了空类一个字节来唯一标识这个类的对象。**  







## 8.3 结构体内存对齐规则  （类也适用）



1. 第一个成员在与结构体偏移量为0的地址处。

2. 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。
   注意：对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。
   VS中默认的对齐数为8

3. 结构体总大小为：最大对齐数（所有变量类型最大者与默认对齐参数取最小）的整数倍。

4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整
   体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。  







>【提醒一些这方面可能会考的面试题】
>
>1. 结构体怎么对齐？ 为什么要进行内存对齐？
>
>2. 如何让结构体按照指定的对齐参数进行对齐？能否按照3、4、5即任意字节对齐？
>
>3. 什么是大小端？如何测试某台机器是大端还是小端，有没有遇到过要考虑大小端的场景  











# 9.this指针  



## 9.1 this指针的引出  

通过上面的叙述我们知道在C++中成员变量和成员函数是分开存储的

每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码

那么问题是：这一块代码是如何区分那个对象调用自己的呢？



我们来看下面这段代码

```c++
class Date
{
public:
	void Init(int year, int month, int day)
	{
		_year = year;
		_month = month;
		_day = day;
	}
	void Print()
	{
		cout << _year << "-" << _month << "-" << _day << endl;
	}
private:
	int _year; // 年
	int _month; // 月
	int _day; // 日
};
int main()
{
	Date d1, d2;
	d1.Init(2022, 10, 3);
	d2.Init(2022, 10, 1);
	d1.Print();
	d2.Print();
	return 0;
}
```

![image-20221003203830516](https://iubaopicbed.oss-cn-shenzhen.aliyuncs.com/img2/picbed202210032038567.png)



对于上述类，有这样的一个问题  

Date类中有 Init 与 Print 两个成员函数，函数体中没有关于不同对象的区分，那当d1调用 Init 函
数时，该函数是如何知道应该设置d1对象，而不是设置d2对象呢？  







c++通过提供特殊的对象指针，this指针，解决上述问题。**this指针指向被调用的成员函数所属的对象**



> 即：C++编译器给每个“非静态的成员函数“增加了一个隐藏
> 的指针参数，让该指针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有“成员变量”
> 的操作，都是通过该指针去访问。只不过所有的操作对用户是透明的，即用户不需要来传递，编
> 译器自动完成  



this指针是隐含每一个非静态成员函数内的一种指针

this指针不需要定义，直接使用即可



this指针的用途：

* 当形参和成员变量同名时，可用this指针来区分

  





## 9.2 this指针的特性  





1. **this指针的类型：类类型\* const**，即成员函数中，不能给this指针赋值。

2. 只能在“成员函数”的内部使用

3. **this指针本质上是“成员函数”的形参**，当对象调用成员函数时，将对象地址作为实参传递给
   this形参。所以**对象中不存储this指针**。

4. **this指针是“成员函数”第一个隐含的指针形参，一般情况由编译器通过ecx寄存器自动传
   递，不需要用户传递**  





![image-20221003204132155](https://iubaopicbed.oss-cn-shenzhen.aliyuncs.com/img2/picbed202210032041223.png)





那么问题来了

1. this指针存在哪呢？



答案：this指针，也是形参，是形参呢一般都存在栈帧中（但是vs下进行了优化，使用ecx寄存器传递）



2. this指针可以为空吗？  



通过两段代码试着理解

```cpp
// 1.下面程序编译运行结果是？ A、编译报错 B、运行崩溃 C、正常运行
class A
{
public:
	void Print()
	{
		cout << "Print()" << endl;
	}
private:
	int _a;
};
int main()
{
	A* p = nullptr;
	p->Print();
	return 0;
}
// 1.下面程序编译运行结果是？ A、编译报错 B、运行崩溃 C、正常运行
class A
{
public:
	void PrintA()
	{
		cout << _a << endl;
	}
private:
	int _a;
};
int main()
{
	A* p = nullptr;
	p->PrintA();
	return 0;
}
```





![image-20221003205731473](https://iubaopicbed.oss-cn-shenzhen.aliyuncs.com/img2/picbed202210032057557.png)
